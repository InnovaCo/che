<!DOCTYPE html><html lang="en"><head><title>app/client/sections/transition</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../../../"><meta name="groc-document-path" content="app/client/sections/transition"><meta name="groc-project-path" content="app/client/sections/transition.coffee"><link rel="stylesheet" type="text/css" media="all" href="../../../assets/style.css"><script type="text/javascript" src="../../../assets/behavior.js"></script><body><div id="meta"><div class="file-path">app/client/sections/transition.coffee</div></div><div id="document"><div class="segment"><div class="code"><div class="wrapper"><span class="cm">#### *module* sections/transition</span>
<span class="cm">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Представляет собой звено для цепочки переходов, получая данные
о секциях, и ссылку на предыдущий переход, конструктор Transition
создает объект Invoker, устанавливает ссылку на новый объект
в предыдущем объекте Transition, и сохраняет ссылку на предыдущий
Transition.
Кроме того проходит по цепочке и удаляет записи, если длина
цепочки превышает 10 объектов</p></div></div><div class="code"><div class="wrapper"><span class="cm">#</span>
<span class="cm">define [</span>
<span class="cm">  &quot;sections/invoker&quot;,</span>
<span class="cm">  &quot;sections/asyncQueue&quot;,</span>
<span class="cm">  &quot;events&quot;,</span>
<span class="cm">  &quot;utils/destroyer&quot;], (Invoker, asyncQueue, events, destroyer) -&gt;</span>

<span class="cm">  transitionsCompressDepth = 5</span>
<span class="cm">  transitionsDestroyDepth = 10</span>
<span class="cm">  </span>
<span class="cm">  ###</span><span class="c1"># Transition(@data)</span>
  <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Конструктор переходов, переходы образуют между собой двусторонний
связанный список</p></div></div><div class="code"><div class="wrapper">  <span class="c1">#</span>
  <span class="nv">Transition = </span><span class="nf">(@state, last) -&gt;</span>
    <span class="vi">@index = @state.index = </span><span class="nx">@state</span><span class="p">.</span><span class="nx">index</span> <span class="o">or</span> <span class="p">(</span><span class="nx">last</span><span class="o">?</span><span class="p">.</span><span class="nx">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">or</span> <span class="mi">0</span>

    
    <span class="k">if</span> <span class="nx">@state</span><span class="p">.</span><span class="nx">sections</span><span class="o">?</span>
      <span class="vi">@_invoker = </span><span class="k">new</span> <span class="nx">Invoker</span> <span class="nx">@state</span><span class="p">.</span><span class="nx">sections</span>
      
    <span class="k">if</span> <span class="nx">last</span><span class="o">?</span>
      <span class="vi">@prev_transition = </span><span class="nx">last</span>
      <span class="nv">last.next_transition = </span><span class="nx">@</span>
      <span class="nx">last</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Удаление старых записей
Стоит отметить, что проход всей цепочки вполне себе хороший способ удалить старые записи
так как позволяет удалять старые записи именно в этой цепочке переходов, не трогая остальные,
которые могут быть созданы про многочиленных переходах по истории и ссылкам на странице
(история может ветвится, но цепочка от конца к началу не имеет ветвления)</p></div></div><div class="code"><div class="wrapper">      <span class="nv">depth = </span><span class="nx">transitionsDestroyDepth</span>
      <span class="nv">prevTransition = </span><span class="nx">@</span>
      <span class="k">while</span> <span class="nx">depth</span><span class="o">--</span>
        <span class="nv">prevTransition = </span><span class="nx">prevTransition</span><span class="p">.</span><span class="nx">prev_transition</span>
        <span class="k">if</span> <span class="o">not</span> <span class="nx">prevTransition</span><span class="o">?</span>
          <span class="k">break</span>

      <span class="nx">prevTransition</span><span class="o">?</span><span class="p">.</span><span class="nx">destroy</span><span class="p">()</span>

    <span class="k">return</span> <span class="nx">@</span>

  <span class="nv">Transition:: =</span>
  
    <span class="cm">#### Transition::update(data)</span>
<span class="cm">    #</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Обновляет данные секций для перехода. Если новые данные совпадают с предыдущими,
то ничего не происходит, иначе запускается механизм обновления секций, прежние
секции удаляются, вместо них вставляются новые.</p></div></div><div class="code"><div class="wrapper"><span class="cm">    #</span>
<span class="cm">    update: (state) -&gt;</span>
<span class="cm">      isStateTheSame = no</span>
<span class="cm">      if @state.url is state.url</span>
<span class="cm">        isStateTheSame = @state.sections is state.sections</span>
<span class="cm">      else</span>
<span class="cm">        return</span>

<span class="cm">      if not isStateTheSame</span>
<span class="cm">        state.index = @index</span>
<span class="cm">        @state = state</span>
<span class="cm">        if @_invoker? and @state.sections?</span>
<span class="cm">          @_invoker.update @state.sections</span>
<span class="cm">        else if @state.sections?</span>
<span class="cm">          @_invoker = new Invoker @state.sections</span>

<span class="cm">        @invoke()</span>

<span class="cm">        asyncQueue.next -&gt;</span>
<span class="cm">          events.trigger &quot;pageTransition:updated&quot;, {}</span>


<span class="cm">    destroy: () -&gt;</span>
<span class="cm">      destroyer @</span>


<span class="cm">    ###</span><span class="c1"># Transition::next([to_transition])</span>
    <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Переход вперед. Требует необязательный параметр to_transition, в котором должен
находится индекс интересующего нас перехода.</p></div></div><div class="code"><div class="wrapper">    <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Полезно, когда нужно перейти на несколько шагов вперед, в случае отсутсвия параметра,
просто происходит переход на один шаг.</p></div></div><div class="code"><div class="wrapper">    <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Если параметр совпадает с индексом перехода, то в очередь asynQueue добавляется инструкция,
вызывающая событие "pageTransition:success", которое означает, что завершилась цепочка переходов</p></div></div><div class="code"><div class="wrapper">    <span class="c1">#</span>
    <span class="nv">next: </span><span class="nf">(to_transition) -&gt;</span>
      <span class="nv">transition = </span><span class="nx">@</span>
      <span class="k">if</span> <span class="nx">to_transition</span> <span class="o">isnt</span> <span class="nx">@index</span> <span class="o">and</span> <span class="nx">@next_transition</span><span class="o">?</span>
        <span class="nv">transition = </span><span class="nx">@next_transition</span>
        <span class="nx">@next_transition</span><span class="p">.</span><span class="nx">invoke</span><span class="p">()</span>
        <span class="k">if</span> <span class="nx">to_transition</span><span class="o">?</span> <span class="k">then</span> <span class="nx">@next_transition</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">to_transition</span><span class="p">)</span>

      <span class="k">if</span> <span class="nx">to_transition</span> <span class="o">is</span> <span class="nx">@index</span> <span class="o">or</span> <span class="o">not</span> <span class="nx">to_transition</span>
        <span class="nx">asyncQueue</span><span class="p">.</span><span class="nx">next</span> <span class="o">-&gt;</span>
          <span class="nx">events</span><span class="p">.</span><span class="nx">trigger</span> <span class="s">&quot;pageTransition:success&quot;</span><span class="p">,</span>
            <span class="nv">transition: </span><span class="nx">transition</span>
      <span class="nx">@</span>

    <span class="cm">#### Transition::next([to_transition])</span>
<span class="cm">    #</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Переход назад. Работает аналогично Transition::next требует необязательный
параметр to_transition, только переходы идут в другом направлении.</p></div></div><div class="code"><div class="wrapper"><span class="cm">    #</span>
<span class="cm">    prev: (to_transition) -&gt;</span>
<span class="cm">      transition = @</span>
<span class="cm">      if to_transition isnt @index and @prev_transition?</span>
<span class="cm">        transition = @prev_transition</span>
<span class="cm">        @undo()</span>
<span class="cm">        if to_transition? then @prev_transition.prev(to_transition)</span>

<span class="cm">      if to_transition is @index or not to_transition</span>
<span class="cm">        asyncQueue.next -&gt;</span>
<span class="cm">          events.trigger &quot;pageTransition:success&quot;,</span>
<span class="cm">            transition: transition</span>
<span class="cm">      @</span>


<span class="cm">    ###</span><span class="c1"># Transition::undo()</span>
    <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Отмена действий перехода. Помимо отката действий объекта Invoker, запускает события "transition:undo" и "transition:current:update",
где в "transition:current:update" передается ссылка на предыдущий переход, а в "transition:undo" на текущий</p></div></div><div class="code"><div class="wrapper">    <span class="c1">#</span>
    <span class="nv">undo: </span><span class="nf">() -&gt;</span>
      <span class="nx">@_invoker</span><span class="o">?</span><span class="p">.</span><span class="nx">undo</span><span class="p">()</span>
      <span class="nx">events</span><span class="p">.</span><span class="nx">trigger</span> <span class="s">&quot;transition:undo&quot;</span><span class="p">,</span> <span class="nx">@</span>
      <span class="nx">events</span><span class="p">.</span><span class="nx">trigger</span> <span class="s">&quot;transition:current:update&quot;</span><span class="p">,</span> <span class="nx">@prev_transition</span>

    <span class="c1">#### Transition::invoke()</span>
    <span class="c1">#</span></div></div></div><div class="segment"><div class="comments"><div class="wrapper"><p>Применение действий перехода. Помимо применения действий объекта Invoker, запускает события "transition:invoked" и "transition:current:update",
где в "transition:current:update" и "transition:invoked" передается ссылка на текущий переход</p></div></div><div class="code"><div class="wrapper">    <span class="c1">#</span>
    <span class="nv">invoke: </span><span class="nf">() -&gt;</span>
      <span class="nx">@_invoker</span><span class="o">?</span><span class="p">.</span><span class="nx">run</span><span class="p">()</span>
      <span class="nx">events</span><span class="p">.</span><span class="nx">trigger</span> <span class="s">&quot;transition:invoked&quot;</span><span class="p">,</span> <span class="nx">@</span>
      <span class="nx">events</span><span class="p">.</span><span class="nx">trigger</span> <span class="s">&quot;transition:current:update&quot;</span><span class="p">,</span> <span class="nx">@</span>


  <span class="k">return</span> <span class="nx">Transition</span></div></div></div></div></body></html>